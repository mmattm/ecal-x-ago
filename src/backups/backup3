/* eslint-disable react/prop-types */
import "./App.css";

import { Canvas, useThree } from "@react-three/fiber";
import { useRef, useState, useEffect } from "react";
import { SplatsView } from "./SplatsView";
import {
  Box,
  OrbitControls,
  SoftShadows,
  ContactShadows,
  Splat,
  Sphere,
  CameraShake,
  Sky,
  Environment,
  CameraControls,
  Grid,
  Line,
} from "@react-three/drei";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { useLoader, useFrame } from "@react-three/fiber";

import gsap from "gsap";

import EnhancedSpotlight from "./EnhancedSpotlight";

import FakeGlowMaterial from "./FakeGlowMaterial";
import { Fog, Vector3, CatmullRomCurve3 } from "three";

export default function App() {
  return (
    <Canvas shadows camera={{ position: [5, 2, 0], fov: 80 }}>
      <Scene />
    </Canvas>
  );
}

function Scene() {
  const cameraControlsRef = useRef();

  // Define the CatmullRomCurve3
  const curve = new CatmullRomCurve3([
    new Vector3(-3, 2, 1),
    new Vector3(2, 2, 0),
    new Vector3(1, 1, 3),
    new Vector3(3, 2, 2),
    new Vector3(-3, 2, 1),
  ]);

  const points = curve.getPoints(50);
  const animationProgress = useRef({ value: 0 });
  const tempVec = new Vector3();

  // Function to start the path animation
  const startAnimation = () => {
    gsap.fromTo(
      animationProgress.current,
      { value: 0 },
      {
        value: 1,
        duration: 16,
        ease: "power1.inOut", // Set easing to 'none' for linear motion
        onUpdate: () => {
          // Store the current point on the curve in tempVec
          curve.getPoint(animationProgress.current.value, tempVec);

          // Use CameraControls to set the camera position and lookAt
          cameraControlsRef.current.setLookAt(
            tempVec.x,
            tempVec.y,
            tempVec.z,
            0,
            0,
            0,
            false
          );
        },
        onStart: () => {
          cameraControlsRef.current.enabled = false;
        },
        onComplete: () => {
          //console.log("Animation complete");

          cameraControlsRef.current.enabled = true;
          // loop
          startAnimation();
        },
      }
    );
  };

  const moveToStartPoint = () => {
    curve.getPoint(0, tempVec);
    cameraControlsRef.current.setLookAt(
      tempVec.x,
      tempVec.y,
      tempVec.z,
      0,
      0,
      0,
      true
    );
  };

  const stopAnimation = () => {
    // Kill the GSAP animation tied to animationProgress.current
    gsap.killTweensOf(animationProgress.current);
    // Reset animation progress
    animationProgress.current.value = 0;
    moveToStartPoint();
    // Re-enable the camera controls
    cameraControlsRef.current.enabled = true;
  };

  // Update camera controls on each frame
  useFrame((_, delta) => {
    if (cameraControlsRef.current) cameraControlsRef.current.update(delta);
  });

  // On Mount
  useEffect(() => {
    if (cameraControlsRef.current) {
      startAnimation();
    }
  }, []);

  const gltf = useLoader(GLTFLoader, "/models/ORIANA_FLAVIA_03.gltf");

  // Traverse the GLTF model and enable shadows
  useEffect(() => {
    if (gltf) {
      gltf.scene.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true; // Enable casting shadows
          child.receiveShadow = true; // Enable receiving shadows (if needed)
        }
      });
    }
  }, [gltf]);

  // Set the camera's initial position
  // useEffect(() => {
  //   if (cameraControlsRef.current) {
  //     // Use CameraControls to set the camera position and lookAt
  //     cameraControlsRef.current.setLookAt(10, 2, 0, 0, 0, 0, true);
  //     cameraControlsRef.current.zoom(1);

  //     // Alternatively, you can set position and lookAt separately
  //     // cameraControlsRef.current.setPosition(1, 2, 5);
  //     // cameraControlsRef.current.setTarget(10, 10, 10);
  //   }
  // }, [cameraControlsRef]);

  // useEffect(() => {
  //   cameraControlsRef.current.enabled = false;
  //   camera.position.set(5, 1, 0);
  //   camera.fov = 50; // Adjust this value to change the FOV
  //   //camera.lookAt(10, 10, 10); // Looks at the origin

  //   camera.updateProjectionMatrix(); // Must call this to apply the new FOV
  // }, [camera]);

  // // Update the camera position in a circular orbit using useFrame
  // useFrame(({ clock }) => {
  //   const elapsedTime = clock.getElapsedTime();
  //   const radius = 1; // Radius of the camera's circular path
  //   const angle = elapsedTime * 0.5; // Adjust this value to change the rotation speed

  //   // Set the camera's position to create a circular orbit around the origin
  //   camera.position.x = radius * Math.sin(angle);
  //   camera.position.z = radius * Math.cos(angle);
  //   camera.position.y = 1;

  //   // Make the camera look at the center of the scene
  //   camera.lookAt(2, 0.5, 0);
  // });

  return (
    // <Canvas shadows={{ type: "VSMShadowMap" }}>
    <>
      <CameraControls ref={cameraControlsRef} />
      <Grid args={[50, 50]} position={[0, 0, 0]} />
      {/* <Line points={points} color={0x00ffff} lineWidth={1} /> */}

      {/* <EffectComposer>
        <DepthOfField
          focusDistance={0}
          focalLength={0.02}
          bokehScale={2}
          height={480}
        />
        <Bloom luminanceThreshold={10} luminanceSmoothing={0.9} height={300} />
        <Noise opacity={0.02} />
      </EffectComposer> */}

      {/* <OrbitControls /> */}
      <SoftShadows size={10} samples={30} focus={2} />
      <Environment preset="sunset" />

      <Sky
        distance={450000}
        sunPosition={[1, 1, 11]}
        inclination={1}
        azimuth={0.25}
      />

      <Line points={points} color={0x00ffff} lineWidth={1} />

      {/* <CameraShake maxYaw={0} maxPitch={0.1} maxRoll={0.1} intensity={1} /> */}

      <directionalLight
        castShadow
        position={[0, 10, 5]}
        intensity={3.5}
        shadow-mapSize={1024}
        // shadow-camera-far={10}
      >
        <orthographicCamera
          attach="shadow-camera"
          args={[-10, 10, -10, 10, 0.1, 600]}
        />
      </directionalLight>

      <ambientLight intensity={2} />

      {/* <group rotation={[Math.PI - 0.1, 0, 0]} position={[0, -1, 0]}> */}
      {/* <group
        rotation={[-Math.PI + 0.1, -Math.PI / 2, 0]}
        position={[1.5, -0.3, -0.8]}
        scale={5}
      >
        <SplatsView
          sources={["/splats/tank.splat"]}
          // sources={[
          //   "https://huggingface.co/datasets/runes/coolsplats/resolve/main/output.splat",
          // ]}
          options={[
            {
              position: [0, 0, 0],
              scale: [1, 1, 1],
              rotation: [0, 0, 0, 0],
              showLoadingUI: false,
              splatAlphaRemovalThreshold: 100,
              progressiveLoad: false,
            },
          ]}
        ></SplatsView>
      </group> */}

      {/* <group
        rotation={[0.09, 0.3, 0.07]}
        position={[1.5, -0.3, -0.8]}
        scale={5}
      >
        <Splat
            src={"/splats/tank.splat"}
            // camera={{ position: [-5, 2, 10], fov: 60 }}
            position={[0, 0, 0]}
            rotation={[-0.1, -0.1, -0.01]} // Example rotation
            chunkSize={25000}
            // alphaTest={0.1}
            // alphaHash={false}
          />
      </group> */}

      {/* <ContactShadows
          position={[0, -0.4, 0]}
          opacity={1}
          scale={10}
          blur={0}
          // resolution={256}
          near={-1}
          far={300}
          rotation={[Math.PI / 2, 0, 0]}
          frames={1}
        /> */}

      <group position={[0.9, 0.3, 0.3]}>
        {/* <Box args={[1, 1, 1]} position={[2, 1, 0]} castShadow receiveShadow /> */}
        <mesh
          rotation={[-Math.PI / 2, 0, 0]}
          position={[0, -0.29, 0]}
          receiveShadow
          renderOrder={1}
        >
          <planeGeometry args={[100, 100]} />
          <shadowMaterial
            transparent
            opacity={0.7}
            // depthWrite={false}
            // depthTest={false}
          />
        </mesh>

        <EnhancedSpotlight
          position={[1, 1, 0]}
          castShadow={false}
          attenuation={2}
          distance={4}
          angle={0.1}
        />

        <Sphere
          args={[0.2, 32, 32]}
          position={[-0.0, 0.64, 0.01]}
          renderOrder={1}
          // castShadow
          // receiveShadow
        >
          {/* <meshPhysicalMaterial color={"blue"} roughness={0.2} /> */}
          <FakeGlowMaterial
            falloff={3}
            glowInternalRadius={5}
            glowColor={"#fff"}
            glowSharpness={1}
            opacity={0.5}
            toneMapped={true}
            depthTest={true}
          />
        </Sphere>

        <primitive
          object={gltf.scene}
          position={[0, -0.3, 0]}
          castShadow
          scale={0.5}
        />
      </group>
    </>
  );
}
